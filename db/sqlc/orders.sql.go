// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrder = `-- name: GetOrder :one
SELECT id, user_id, market, side, price, quantity, remaining, status, created_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Market,
		&i.Side,
		&i.Price,
		&i.Quantity,
		&i.Remaining,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, user_id, market, side, price, quantity, remaining, status, created_at FROM orders
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetOrderForUpdate(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Market,
		&i.Side,
		&i.Price,
		&i.Quantity,
		&i.Remaining,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT id, user_id, market, side, price, quantity, remaining, status, created_at
FROM orders
WHERE (
        $1::uuid IS NULL
        OR user_id = $1
      )
  AND (
        COALESCE($2, '') = ''
        OR status = $2
      )
  AND (
        COALESCE($3, '') = ''
        OR side = $3
      )
  AND (
        $4::timestamptz IS NULL
        OR (created_at, id) > (
              $4::timestamptz,
              COALESCE($5::uuid, '00000000-0000-0000-0000-000000000000'::uuid)
          )
      )
ORDER BY created_at, id
LIMIT $6
`

type ListOrdersParams struct {
	Column1 pgtype.UUID
	Column2 interface{}
	Column3 interface{}
	Column4 pgtype.Timestamptz
	Column5 pgtype.UUID
	Limit   int32
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Market,
			&i.Side,
			&i.Price,
			&i.Quantity,
			&i.Remaining,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestingAsks = `-- name: ListRestingAsks :many


SELECT id, user_id, market, side, price, quantity, remaining, status, created_at
FROM orders
WHERE status IN ('OPEN','PARTIAL')
  AND side = 'SELL'
  AND (
        $1::text IS NULL
        OR $1 = ''
        OR market = $1
      )
ORDER BY price ASC, created_at ASC, id ASC
`

// Keyset pagination with (created_at, id)
func (q *Queries) ListRestingAsks(ctx context.Context, dollar_1 string) ([]Order, error) {
	rows, err := q.db.Query(ctx, listRestingAsks, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Market,
			&i.Side,
			&i.Price,
			&i.Quantity,
			&i.Remaining,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestingBids = `-- name: ListRestingBids :many
SELECT id, user_id, market, side, price, quantity, remaining, status, created_at
FROM orders
WHERE status IN ('OPEN','PARTIAL')
  AND side = 'BUY'
  AND (
        $1::text IS NULL
        OR $1 = ''
        OR market = $1
      )
ORDER BY price DESC, created_at ASC, id ASC
`

func (q *Queries) ListRestingBids(ctx context.Context, dollar_1 string) ([]Order, error) {
	rows, err := q.db.Query(ctx, listRestingBids, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Market,
			&i.Side,
			&i.Price,
			&i.Quantity,
			&i.Remaining,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOrderCancelled = `-- name: MarkOrderCancelled :exec
UPDATE orders
SET status = 'CANCELLED'
WHERE id = $1
  AND status IN ('OPEN','PARTIAL')
`

func (q *Queries) MarkOrderCancelled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markOrderCancelled, id)
	return err
}

const updateOrderAfterMatch = `-- name: UpdateOrderAfterMatch :exec
UPDATE orders
SET remaining = $2,
    status = $3
WHERE id = $1
`

type UpdateOrderAfterMatchParams struct {
	ID        pgtype.UUID
	Remaining pgtype.Numeric
	Status    string
}

func (q *Queries) UpdateOrderAfterMatch(ctx context.Context, arg UpdateOrderAfterMatchParams) error {
	_, err := q.db.Exec(ctx, updateOrderAfterMatch, arg.ID, arg.Remaining, arg.Status)
	return err
}

const upsertOrder = `-- name: UpsertOrder :one
INSERT INTO orders (
    id, user_id, market, side, price, quantity, remaining, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (id) DO UPDATE
SET remaining = EXCLUDED.remaining,
    status    = EXCLUDED.status
RETURNING id, user_id, market, side, price, quantity, remaining, status, created_at
`

type UpsertOrderParams struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	Market    string
	Side      string
	Price     pgtype.Numeric
	Quantity  pgtype.Numeric
	Remaining pgtype.Numeric
	Status    string
}

func (q *Queries) UpsertOrder(ctx context.Context, arg UpsertOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, upsertOrder,
		arg.ID,
		arg.UserID,
		arg.Market,
		arg.Side,
		arg.Price,
		arg.Quantity,
		arg.Remaining,
		arg.Status,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Market,
		&i.Side,
		&i.Price,
		&i.Quantity,
		&i.Remaining,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
